'''
Created on 5 Nov 2015

@author: Sara
'''

class ParseInterOpMetrics(object):
    '''
    A series of methods to parse the InterOp binary files generated by the MiSeqReporter software
    Supported versions of files are specified in Import.py (as this collection of functions is called by that script)
    '''
    #Class variables (i.e. not specific to a single instance)- similar but not the same as static variables in java
    #http://www.toptal.com/python/python-class-attributes-an-overly-thorough-guide
    
    def __init__(self,filehandle):
        #global ENDIANNESS
        #global ENCODING_DICTIONARY
        import struct as s
        self.s = s
        import datetime as dt
        self.dt = dt
        import math
        self.math = math
        self.Y = 6 #Known index of Y in the bytearray- could attempt to retrieve this better another time
        self.YV = 4 #Known size of YV- could attempt to retrieve this better another time
        self.file_handle = filehandle
        self.ENDIANNESS = "<"
        self.ENCODING_DICTIONARY = {"x":1,"c":1,"b":1,"B":1,"?":1,"h":2,"H":2,"i":4,"I":4,"l":4,"L":4,"q":8,"Q":8,"f":4,"d":8,"s":1,"p":1,"P":1}
    
    def open_file_to_bytearray(self,filehandle):
        '''
        For all supported binary InterOp files
        Reads the data specified in the file pointed to by the filehandle and outputs it as a bytearray 
        '''
        values = bytearray()
        with open(filehandle, "rb") as f:
            for line in f:
                for b in line:
                    values.append(b)
        return values #This is the bytearray of the data
    
    def convert_bytes_index(self,the_bytearray,supported_version_number):
        '''
        For the IndexMetricsOut.bin file
        Unpacks the byte encoding the version of the file and checks that it is a supported version
        Returns the starting byte for the data encoded in the rest of the bytearray
        '''
        for index in xrange(len(the_bytearray)):
            byte_start = (index) #This will be where I will want to start the next readout from
            if index < 1:
                value = self.s.unpack_from(self.ENDIANNESS + "B",the_bytearray,index)
                if value[0] != supported_version_number:
                    raise Exception("Unsupported file version")
            else:
                #return get_chunk_len(byte_start,the_bytearray)
                #print byte_start
                return byte_start
            
    def get_Y(self,readout_start,the_bytearray,offset=0):
        '''
        For the IndexMetricsOut.bin file
        There are three variable length records in this file. This function reads out the length of the 
        variable length string specified as Y in the Illumina specification documentation
        Takes as input the output of the function convert_bytes_index (indicating the starting position of the 
        first record in the bytearray), the the bytearray output by the function open_file_to_bytearray, the 
        entry length which is output by the function get_entry_len_ind and the offset which indicates the position 
        of the record in the whole bytearray being parsed and is counted in the calling function 
        (PopulateBinaryTablesIndexClass)
        Outputs the length of the variable length string Y
        '''
        ind_Y = self.Y
        index_bytes_length = self.ENCODING_DICTIONARY.get("H",None)
        Y = self.s.unpack_from(self.ENDIANNESS + "H",the_bytearray[(offset+readout_start+ind_Y):(offset+readout_start+ind_Y+index_bytes_length)],0)
        return Y[0]
    
    def get_V(self,readout_start,the_bytearray,offset=0):
        '''
        For the IndexMetricsOut.bin file
        There are three variable length records in this file. This function reads out the length of the 
        variable length string specified as V in the Illumina specification documentation
        Takes as input the output of the function convert_bytes_index (indicating the starting position of the 
        first record in the bytearray), the the bytearray output by the function open_file_to_bytearray, the 
        entry length which is output by the function get_entry_len_ind and the offset which indicates the position 
        of the record in the whole bytearray being parsed and is counted in the calling function 
        (PopulateBinaryTablesIndexClass)
        Outputs the length of the variable length string V
        '''
        ind_Y = self.Y
        ind_YV = self.YV
        index_bytes_length = self.ENCODING_DICTIONARY.get("H",None)
        Y = self.s.unpack_from(self.ENDIANNESS + "H",the_bytearray[(offset+readout_start+ind_Y):(offset+readout_start+ind_Y+index_bytes_length)],0)
        ind_V = ind_Y + index_bytes_length + Y[0] + ind_YV
        V = self.s.unpack_from(self.ENDIANNESS + "H",the_bytearray[(offset+readout_start+ind_V):(offset+readout_start+ind_V+index_bytes_length)],0)
        return V[0]
    
    def get_W(self,readout_start,the_bytearray,offset=0):
        '''
        For the IndexMetricsOut.bin file
        There are three variable length records in this file. This function reads out the length of the 
        variable length string specified as W in the Illumina specification documentation
        Takes as input the output of the function convert_bytes_index (indicating the starting position of the 
        first record in the bytearray), the the bytearray output by the function open_file_to_bytearray, the 
        entry length which is output by the function get_entry_len_ind and the offset which indicates the position 
        of the record in the whole bytearray being parsed and is counted in the calling function 
        (PopulateBinaryTablesIndexClass)
        Outputs the length of the variable length string W
        '''
        ind_Y = self.Y
        ind_YV = self.YV
        index_bytes_length = self.ENCODING_DICTIONARY.get("H",None)
        Y = self.s.unpack_from(self.ENDIANNESS + "H",the_bytearray[(offset+readout_start+ind_Y):(offset+readout_start+ind_Y+index_bytes_length)],0)
        ind_V = ind_Y + index_bytes_length + Y[0] + ind_YV
        V = self.s.unpack_from(self.ENDIANNESS + "H",the_bytearray[(offset+readout_start+ind_V):(offset+readout_start+ind_V+index_bytes_length)],0)
        ind_W = ind_V + index_bytes_length + V[0]
        W = self.s.unpack_from(self.ENDIANNESS + "H",the_bytearray[(offset+readout_start+ind_W):(offset+readout_start+ind_W+index_bytes_length)],0)
        return W[0]
    
    def get_entry_len_ind(self,readout_start,the_bytearray,offset=0):
        '''
        For the IndexMetricsOut.bin file
        As each record is of variable length, this function reads out the size of the 'chunk' of the bytearray
        which corresponds to the record about to be parsed
        Takes as input the output of the function convert_bytes_index (indicating the starting position of the 
        first record in the bytearray), the the bytearray output by the function open_file_to_bytearray, the 
        entry length which is output by the function get_entry_len_ind and the offset which indicates the position 
        of the record in the whole bytearray being parsed and is counted in the calling function 
        (PopulateBinaryTablesIndexClass)
        Outputs the length of the record
        '''
        ind_Y = self.Y
        ind_YV = self.YV
        index_bytes_length = self.ENCODING_DICTIONARY.get("H",None)
        Y = self.s.unpack_from(self.ENDIANNESS + "H",the_bytearray[(offset+readout_start+ind_Y):(offset+readout_start+ind_Y+index_bytes_length)],0)
        ind_V = ind_Y + index_bytes_length + Y[0] + ind_YV
        V = self.s.unpack_from(self.ENDIANNESS + "H",the_bytearray[(offset+readout_start+ind_V):(offset+readout_start+ind_V+index_bytes_length)],0)
        ind_W = ind_V + index_bytes_length + V[0]
        W = self.s.unpack_from(self.ENDIANNESS + "H",the_bytearray[(offset+readout_start+ind_W):(offset+readout_start+ind_W+index_bytes_length)],0)
        return (ind_W + index_bytes_length + W[0])
    
    def get_array_segment(self,readout_start,the_bytearray,entry_length,offset):
        '''
        For all supported InterOp files
        Takes as input the output of the functions convert_bytes_index for the IndexMetricsOut.bin file
        and convert_bytes for all other supported files (indicating the starting position of the first record
        in the bytearray), the bytearray output by the function open_file_to_bytearray, the entry length which 
        is output by the functions get_entry_len_ind for the IndexMetricsOut.bin file and get_entry_len for all 
        other supported files, and the offset which indicates the position of the record in the whole bytearray
        being parsed and is counted in the calling function (PopulateBinaryTables...).
        This function reads out the array segment for de-encoding (i.e. the bit which corresponds to a single record)
        and outputs this as a bytearray
        '''
        byte_start = readout_start + offset
        return the_bytearray[byte_start:(byte_start+entry_length)]
    
    def get_encoding_string_var(self,Y,V,W,encoding):
        '''
        For the IndexMetricsOut.bin file
        Necessary function to cope with when the encoding string codes for variable values indicating the length of the
        subsequent string
        Takes as input the results of the functions get_Y, get_V and get_W, indicating the locations of the variables 
        describing the length of the variable length strings, and the encoding string as specified by Illumina
        Outputs a new encoding string with the correct number of character specifiers to match the variable length
        of string for each record
        '''
        encoding_constants = (Y,V,W)
        let = []
        count = 0
        for letter in encoding:
            if letter != 's':
                let.append(letter)
            elif letter == 's':
                #print "arr_start is " + str(arr_start)
                let.pop() #Pop from the stack (pop always pops from the end of a stack)
                let.append(letter*encoding_constants[count])
                encoding_string = "".join(let)
                count += 1
        return encoding_string
    
    def get_values_simple(self,encoding_string,array_segment):
        '''
        For all supported InterOp files
        Returns the de-encoded section of the bytearray passed in according to the specifications in the
        encoding string
        Requires as input the encoding string and the section of the bytearray to be de-encoded
        '''
        return self.s.unpack_from(self.ENDIANNESS + encoding_string,array_segment)
    
    def handle_nan(self,lst):
        '''
        For all supported InterOp files
        Takes as input the de-encoded section of the bytearray corresponding to a single record
        Replaces NaNs with 0s and outputs the new record as a list
        Currently increases the run-time of the code. Requires improvement.
        '''
        new_list = []
        for entry in lst:
            #print entry
            #print type(entry)
            if self.math.isnan(entry):
                new_list.append(0)
            else:
                new_list.append(entry)
        return new_list
                      
    
    def get_datetime(self,encoding_string,array_segment):
        '''
        For the ExtractionMetricsOut.bin file
        Takes the segment of the bytearray corresponding to a record and the encoding string specified 
        (which it uses to find the position into the bytearray where the datetime entry begins) as input
        Outputs the date and time (in the format output by the datetime library) as a string
        '''
        size = 0
        for enc in encoding_string:
            enc_size = self.ENCODING_DICTIONARY.get(enc,None)
            size += enc_size
        #return size
        dt_bytes = array_segment[size:len(array_segment)]
        bitlst = []
        for b in dt_bytes:
            for i in (xrange(8)): #reversed(xrange(8)): The reversed here doesn't work as it is byte order reversed as well as bit order within bytes
                bitlst.append((b >> i) & 1)
        bitlst[((len(dt_bytes)*8)-1)] = 0
        bitlst[((len(dt_bytes)*8)-2)] = 0
        binary = ''.join(str(c) for c in bitlst)[::-1] #Reversed as is little endian
        ticks = int(binary,2)
        datetime = self.dt.datetime(1, 1, 1) + self.dt.timedelta(microseconds = ticks/10)
        return str(datetime)
    
    def get_s(self,encoding):
        '''
        For the IndexMetricsOut.bin file
        Required to handle the variable length strings.
        Finds the positions of the s's in the encoding string and outputs these in a list
        Takes as input the output of the encoding_string function (get_encoding_string_var), NOT the raw encoding string.
        '''
        s_indices = []
        for index,letter in enumerate(encoding):
            if letter == 's' and encoding[index-1] != 's': #Index of first s each time
                s_indices.append(index)   
        return s_indices
    
    def get_formatted_values(self,Y,V,W,s_indices,raw_result):
        '''
        For the IndexMetricsOut.bin file
        Joins together the characters comprising the strings so that each one is not a new entry.
        Currently they are de-encoded as individual characters and the output from the struct library supplies
        each as an individual character in a list, which should be entered into the database as a string (single entry)
        Also removes the numbers encoding the string lengths as they are not useful data to be stored in the database.
        Requires as input the output from the functions get_s (s_indices), get_Y, get_V, and get_W, which give the position
        of the lengths of each variable length string for this record as well as the locations of the encoding s, indicating
        string, in the encoding string which is passed as input to the struct library. Also requires initial output 
        from use of the struct library, which contains all the characters as separate entries (raw_result).
        '''        
        #Create a list for the new data
        formatted = []
        for entry in raw_result[0:(s_indices[0]-1)]: #-1 removes the entry denoting the string length
            formatted.append(entry)
        formatted.append("".join(raw_result[s_indices[0]:((s_indices[0])+Y)]))
        for entry in raw_result[((s_indices[0])+Y):(s_indices[1]-1)]: #-1 removes the entry denoting the string length
            formatted.append(entry)
        formatted.append("".join(raw_result[s_indices[1]:((s_indices[1])+V)]))
        if len(s_indices) < 3:
            formatted.append(' ')
        else:
            for entry in raw_result[((s_indices[1])+V):(s_indices[2]-1)]: #-1 removes the entry denoting the string length
                formatted.append(entry)
            formatted.append("".join(raw_result[s_indices[2]:((s_indices[2])+W)]))
        return formatted
        for entry in raw_result[((s_indices[1])+V):(s_indices[2]-1)]: #-1 removes the entry denoting the string length
            formatted.append(entry)
        formatted.append("".join(raw_result[s_indices[2]:((s_indices[2])+W)]))
        return formatted
    
    
    def convert_bytes(self,the_bytearray,supported_version_number):
        '''
        For all binary files supported except the IndexMetricsOut.bin file
        Unpacks the byte encoding the version of the file and checks that it is a supported version
        Returns the starting byte for the data encoded in the rest of the bytearray
        '''
        for index in xrange(len(the_bytearray)):
            byte_start = (index) #This will be where I will want to start the next readout from
            if index < 2: #FIX HERE SEE OTHER PARSER
                value = self.s.unpack_from(self.ENDIANNESS + "B",the_bytearray,index)
                if (index == 0) and value[0] != supported_version_number:
                    raise Exception("Unsupported file version")
            else:
                #return get_chunk_len(byte_start,the_bytearray)
                return byte_start
    
    
    
    def get_entry_len(self,the_bytearray):
        '''
        For all binary files supported except the IndexMetricsOut.bin file
        Finds the length of the bytearray (it is encoded in the first byte) and returns this
        Takes the bytearray created by the function open_file_to_bytearray as input
        '''
        for index in xrange(len(the_bytearray)):
            if index == 1: #First byte is the length of the record
                value = self.s.unpack_from(self.ENDIANNESS + "B",the_bytearray,index)
                return value[0]
                #return value
            
            #else:
                #return get_chunk_len(byte_start,the_bytearray)
                #return byte_start
